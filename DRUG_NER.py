# -*- coding: utf-8 -*-
"""NER_GITHUB.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gvKD45h8fLcxaIQGRlDufe-G--DxgZZi

NAMED ENTITY RECOGNITION MODEL -

*note* : model can only recognize trained drug names

importing libraries and packages
"""

import pandas as pd
import numpy as np
from tensorflow.keras.layers import Dropout

from sklearn.model_selection import train_test_split
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Embedding, LSTM, Dense
from keras.preprocessing.text import Tokenizer
from tensorflow.keras import regularizers
from keras.layers import LSTM, Embedding, Dense, TimeDistributed, Dropout, Bidirectional,GRU,SimpleRNN
import nltk
nltk.download('punkt')

"""Loading NER dataset"""

# Sample NER data (replace with your actual NER data)
ner_data = pd.read_csv('comments_boi.csv',encoding='utf-8')
ner_data.head()

"""Pre processing"""

# Preprocessing
ner_data['Word'] = ner_data['Word'].astype(str)
ner_data['Tag'] = ner_data['Tag'].astype(str)

# Tokenization
max_words = 5000
tokenizer = Tokenizer(num_words=max_words, oov_token='<OOV>')
tokenizer.fit_on_texts(ner_data['Word'])

# Convert text to sequences
X = tokenizer.texts_to_sequences(ner_data['Word'])
X = pad_sequences(X)

# Convert labels to categorical
y =ner_data.Tag.replace({'O': 0, 'Condition':1,'Drug':2})

y=pd.get_dummies(ner_data['Tag']).values

"""Spliting the NER dataset into Train and Test"""

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""Building the LSTM model"""

# Build the LSTM model
embedding_dim = 32
model = Sequential()
model.add(Embedding(input_dim=max_words, output_dim=embedding_dim, input_length=X.shape[1]))
model.add(LSTM(units=32, dropout=0.2, recurrent_dropout=0.2))#kernel_regularizer=regularizers.l2(0.01)))
model.add(Dropout(0.2))  # Add dropout layer with higher dropout rate
model.add(Dense(y.shape[1], activation='softmax'))

model.compile(loss='categorical_crossentropy', optimizer='rmsprop', metrics=['accuracy'])

"""Fitting the NER model"""

# Train the model
epochs = 2
batch_size = 1024
history = model.fit(X_train, y_train, epochs=epochs, batch_size=batch_size, validation_data=(X_test, y_test), verbose=1)

# Evaluate NER model
ner_loss, ner_accuracy = model.evaluate(X_test,y_test)
print(f'NER Model Accuracy: {ner_accuracy:.2f}')

import nltk
from keras.preprocessing.sequence import pad_sequences

unseen_review = "this PREMARIN drug was very effective and cured my disease"

# Assuming 'words' and 'tags' are lists containing words and corresponding tags from your NER data
words = ner_data['Word'].tolist()
tags = ner_data['Tag'].tolist()

# Assuming 'drug_name_column' is the column in your dataset that contains drug names
drug_names = ner_data['urlDrugName'].unique()

# Assuming 'condition_column' is the column in your dataset that contains condition names
condition_names = ner_data['condition'].unique()

# Initialize variables to store found drug name, condition name, and entities
found_drug_name = None
found_condition_name = None
found_drug_entity = None
found_condition_entity = None

# Check if any drug name from the dataset is present in the unseen drug review
for drug_name in drug_names:
    if drug_name.lower() in unseen_review.lower():  # Case insensitive check
        # Get the corresponding entity for the drug name from the tags list
        entity_index = words.index(drug_name.lower()) if drug_name.lower() in words else -1
        if entity_index != -1:
            found_drug_name = drug_name
            found_drug_entity = tags[entity_index]
            break  # Exit loop if a drug name match is found

# Check if any condition name from the dataset is present in the unseen drug review
for condition_name in condition_names:
    if isinstance(condition_name, str) and condition_name.lower() in unseen_review.lower():  # Check if condition_name is a string
        # Get the corresponding entity for the condition name from the tags list
        entity_index = words.index(condition_name.lower()) if condition_name.lower() in words else -1
        if entity_index != -1:
            found_condition_name = condition_name
            found_condition_entity = tags[entity_index]
            break  # Exit loop if a condition name match is found

# Print the found drug name, condition name, and entities
if found_drug_name and found_drug_entity:
    print("Found drug name in the review:", found_drug_name)
    print("Entity of the drug name:", found_drug_entity)

if found_condition_name and found_condition_entity:
    print("Found condition name in the review:", found_condition_name)
    print("Entity of the condition name:", found_condition_entity)

if not found_drug_name and not found_condition_name:
    print("No drug or condition name from the dataset found in the review.")

# Tokenize and preprocess the unseen drug review for model prediction
unseen_review_tokens = [word.lower() for word in nltk.word_tokenize(unseen_review)]
unseen_sequence = tokenizer.texts_to_sequences([unseen_review_tokens])
unseen_sequence = pad_sequences(unseen_sequence, maxlen=X.shape[1])

# Make predictions using the trained model
predictions = model.predict(unseen_sequence)

# Process predictions to extract entities
#predicted_labels

import nltk
from keras.preprocessing.sequence import pad_sequences

unseen_review = "premarin effectively relieves pain, but causes occasional allergic reactions"

# Assuming 'words' and 'tags' are lists containing words and corresponding tags from your NER data
words = ner_data['Word'].tolist()
tags = ner_data['Tag'].tolist()

# Assuming 'drug_name_column' is the column in your dataset that contains drug names
drug_names = ner_data['urlDrugName'].unique()

# Assuming 'condition_column' is the column in your dataset that contains condition names
condition_names = ner_data['condition'].unique()

# Initialize variables to store found drug name, condition name, and entities
found_drug_name = None
found_condition_name = None
found_drug_entity = None
found_condition_entity = None

# Check if any drug name from the dataset is present in the unseen drug review
for drug_name in drug_names:
    if drug_name.lower() in unseen_review.lower():  # Case insensitive check
        # Get the corresponding entity for the drug name from the tags list
        entity_index = words.index(drug_name.lower()) if drug_name.lower() in words else -1
        if entity_index != -1:
            found_drug_name = drug_name
            found_drug_entity = tags[entity_index]
            break  # Exit loop if a drug name match is found

# Check if any condition name from the dataset is present in the unseen drug review
for condition_name in condition_names:
    if isinstance(condition_name, str) and condition_name.lower() in unseen_review.lower():  # Check if condition_name is a string
        # Get the corresponding entity for the condition name from the tags list
        entity_index = words.index(condition_name.lower()) if condition_name.lower() in words else -1
        if entity_index != -1:
            found_condition_name = condition_name
            found_condition_entity = tags[entity_index]
            break  # Exit loop if a condition name match is found

# Print the found drug name, condition name, and entities
if found_drug_name and found_drug_entity:
    print("Found drug name in the review:", found_drug_name)
    print("Entity of the drug name:", found_drug_entity)

if found_condition_name and found_condition_entity:
    print("Found condition name in the review:", found_condition_name)
    print("Entity of the condition name:", found_condition_entity)

if not found_drug_name and not found_condition_name:
    print("No drug or condition name from the dataset found in the review.")

# Tokenize and preprocess the unseen drug review for model prediction
unseen_review_tokens = [word.lower() for word in nltk.word_tokenize(unseen_review)]
unseen_sequence = tokenizer.texts_to_sequences([unseen_review_tokens])
unseen_sequence = pad_sequences(unseen_sequence, maxlen=X.shape[1])

# Make predictions using the trained model
predictions = model.predict(unseen_sequence)



import nltk
from keras.preprocessing.sequence import pad_sequences

unseen_review = "After taking lamictal, i have experienced side effects"

# Assuming 'words' and 'tags' are lists containing words and corresponding tags from your NER data
words = ner_data['Word'].tolist()
tags = ner_data['Tag'].tolist()

# Assuming 'drug_name_column' is the column in your dataset that contains drug names
drug_names = ner_data['urlDrugName'].unique()

# Assuming 'condition_column' is the column in your dataset that contains condition names
condition_names = ner_data['condition'].unique()

# Initialize variables to store found drug name, condition name, and entities
found_drug_name = None
found_condition_name = None
found_drug_entity = None
found_condition_entity = None

# Check if any drug name from the dataset is present in the unseen drug review
for drug_name in drug_names:
    if drug_name.lower() in unseen_review.lower():  # Case insensitive check
        # Get the corresponding entity for the drug name from the tags list
        entity_index = words.index(drug_name.lower()) if drug_name.lower() in words else -1
        if entity_index != -1:
            found_drug_name = drug_name
            found_drug_entity = tags[entity_index]
            break  # Exit loop if a drug name match is found

# Check if any condition name from the dataset is present in the unseen drug review
for condition_name in condition_names:
    if isinstance(condition_name, str) and condition_name.lower() in unseen_review.lower():  # Check if condition_name is a string
        # Get the corresponding entity for the condition name from the tags list
        entity_index = words.index(condition_name.lower()) if condition_name.lower() in words else -1
        if entity_index != -1:
            found_condition_name = condition_name
            found_condition_entity = tags[entity_index]
            break  # Exit loop if a condition name match is found

# Print the found drug name, condition name, and entities
if found_drug_name and found_drug_entity:
    print("Found drug name in the review:", found_drug_name)
    print("Entity of the drug name:", found_drug_entity)

if found_condition_name and found_condition_entity:
    print("Found condition name in the review:", found_condition_name)
    print("Entity of the condition name:", found_condition_entity)

if not found_drug_name and not found_condition_name:
    print("No drug or condition name from the dataset found in the review.")

# Tokenize and preprocess the unseen drug review for model prediction
unseen_review_tokens = [word.lower() for word in nltk.word_tokenize(unseen_review)]
unseen_sequence = tokenizer.texts_to_sequences([unseen_review_tokens])
unseen_sequence = pad_sequences(unseen_sequence, maxlen=X.shape[1])

# Make predictions using the trained model
predictions = model.predict(unseen_sequence)